---
title: "Election Violence Database Structure"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Election Violence Database Structure}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# devtools::install_github("bergant/datamodelr")
library(datamodelr)
```

This vignette describes the election violence database . 

## Overview of Database Structure

The election violence database contains information in four connected sections:

1.  **Event Report Coding**: The main section of the database contains all the project coding of reports of election violence in nineteenth and early twentieth century newspapers. Most users will be interested only (or primarily) in this part of the database. 

1.  **Source Material** The second section of the database contains information about the source material and search strategies used by the project to find that source material. 

1.  **Users** The third section of the database contains data about users.

1.  **Clustering** The fourth section of the database contains the data collected during the clustering process which grouped reports of the same event together.  

The diagram below shows the overall tabular structure of each section of the database. The diagram shows the primary and foreign key columns in each table, so the figure can serve as a reference for joining tables within and between sections. However, on first read through it is probably enough to note the broad relationship between the four sections of the database, and that there can be multiple tables in each section.


**Is this diagram too complex to go here? Could have a simple section level figure of the database here and put this diagram later (perhaps at the end).**
```{r, echo=FALSE, fig.height=7, fig.width=7}


dm <- datamodelr::dm_read_yaml("evp_erd.yml")
graph <- dm_create_graph(dm, view_type = "keys_only")
dm_render_graph(graph)
```

 

## Event Report Coding Tables

The main part of the database contains all the project coding of reports of election violence in nineteenth and early twentieth century newspapers. Most users will be interested only (or primarily) in this part of the database. The codings were generated by expert coders (users) reading newspaper articles (documents) and recording information about reports of election violence events reported in those newspaper articles, together with further classification of the event reports (tags and attributes). This coding is recorded in four related tables: 

1.  *user_docs* This table contains information about the allocation of users to newspaper articles. Each row in this table records the particular combination of user and document (allowing that users were responsible for coding multiple documents and one document could be coded by multiple different users).   
1.  **event_reports** This table stores information about reports of election violence. Each row in this table is a record of a report of an election violence incident (found in a particular newspaper article by a particular user). **This is probably the table in the database which users will want to understand first.**  
1.  *tags* This table stores further information about reported events like the location(s) where it took place, the actors involved in the event, and the kinds of action which constituted the event. Multiple tags of every kind could be associated with one reported event (e.g. an event could be associated with multiple locations, multiple actors and multiple actions).
1.  *attributes* The tags and attributes tables work together to store classificaiton information about events. Basic classification information is stored in the tags table. The attributes table supplements the tags table with further more detailed information, where this information is associated with particular tags. This two layer structure enables flexible storage of classification information at different levels of granularity and in different ways. For example, if a tag identifies that the event report involes a violent disturbance, attributes might identify whether that this violent disturbance, was described as a riot in the press, had the riot act read and what the crowd size involved with the disturbance was.

The diagram below shows the fields in these four tables, and indicates how these four tables relate to each other. 

```{r, echo=FALSE, fig.height=7, fig.width=7}


graph <- dm_create_graph(dm, rankdir="RL", focus=list(tables = c("userdocumentallocation", "event_reports", "tag", "attribute")))
dm_render_graph(graph)
```

### user_docs (userdocumentallocation)
*Gary/Patrick we need a description of the table and the fields in the table here *

### event_reports

This table stores information about reports of election violence. Each row in this table is a record of a report of an election violence incident (found in a particular newspaper article by a particular user). **This is probably the table in the database which users will want to understand first.**  

*Gary/Patrick we need a description of the table and the fields in the table here *

### tag 
*Gary/Patrick we need a description of the table and the fields in the table here *
test

### attribute
*Gary/Patrick we need a description of the table and the fields in the table here *


## Sources Tables
The sources section of the database is designed to store information about the source documents which the reports of election violence are drawn from. Every event report is connected to a particular document (newspaper article). We located these documents by a search process. This search process involved:
1.Entering keywords into online newspaper archive search masks (overwhelmingly using the British Newspaper Archive)
1. Obtaining a set of results, that is the set of (links to) documents returned by the search.
1. Building the set of all newspaper articles returned by any search we conducted, with information about the article (these are the candidate documents - documents which may contain reference to election violence)
1. Selecting documents to code for instances of election violence.

The sources section of the database stores information about these documents, and connects these documents we found back through to the search process by which we found them. The information is stored in the following tables:

1. *archivesearches* This table stores information about the keyword searches we conducted.
1. *archivesearchresults* This table stores information about the results returned by the online archives in reponse to our keyword searches.
1. *candidatedocuments* This table indexes and table stores information about archive search results (so that a candidate document may appear in one or more rows in archivesearchresults).
1. *documents* This table stores information about the subset of candidate documents that were considered sufficiently likely to contain election violence incidents and were thus worth reading and coding. Every election violence report in the database is drawn from a document with an entry in this table. 

There is one additional table in the sources section of the database: *archivesearchsummaryonly*. This contains aggregate information (the number of results returned) about some searches. This information  does not connect to the event reports. Similar aggregate information, like the number of results returned, about searches which do connect to the event reports can be calculated from the archivesearchresults table.

```{r, echo=FALSE, fig.height=7, fig.width=7}


graph <- dm_create_graph(dm, focus=list(tables = c("documents", "candidatedocument", "archivesearchsummaryonly", "archivesearchresult", "archivesearch")), rankdir="RL")
dm_render_graph(graph)
```


**Gary/Patrick we need a table/field level description of each of these tables here**

## Users Tables
The users section of the database contains just one table which store information about database users. 
```{r, echo=FALSE}


graph <- dm_create_graph(dm, focus=list(tables = c("user")))
dm_render_graph(graph)
```


**Gary/Patrick we need a field level description of this table here**

## Clustering Tables

Most election violence events were reported many times in the nineteenth and early twentieth century newspapers, we have for example coded more than 150  newspaper articles reporting the 1857 election riot in Kidderminster. The clustering section of the database contains the information on the relationship between different event reports, and particularly which event reports are considered to be about the same underlying event. The clustering was done after all the event reports were collected. 

The idea of the clustering process is that every in scope^[Event reports are in scope if the coding is complete, the document is relevant, the event report relates to a general election, and if coding was undertaken in coding (as opposed to training or testing) modes. Out of scope event reports remain in the database but were not clustered.] event report should be a member of exactly one final cluster (combination cluster). The key information about any event report is its final (combination) cluster which is recorded in the combinedclusterentry table, which is linked back to event reports through the verifiedcluster and verifiedclusterentry table.

The database allows for this clustering process to be undertaken multiple times (different cluster attempts). Different cluster attempts are recorded in the clusterattempt_id column of the verified cluster table. The final cluster of an event report should therefore be unique *within* a particular cluster attempt.

The database contains stores information on multiple partial, and two major cluster attempts. **Gary should we add information here about the clusterattempts with ids?**. 

These clusters were created a sequential grouping and comparison process:

1.  *Autoclustering:* Event reports with very similar features (e.g. similar locations in the same election) were put into clusters (autoclusters) by an automated algorithm
2.  *Verification* Coders compare all event reports in an autocluster, splitting as necessary to form a 'verified cluster'. 
3.  *Reallocation:* 'Orphan' event reports which were not part of a larger group at the autocluster stage were compared with all of these 'verified clusters', and reallocated to an existing or new verified cluster.
4.  *Combination* Verified clusters were compared to each other, and where verified clusters were determined to refere to the same underlying event, verified clusters were combined into larger final or 'combination clusters'. 

The clustering process was conducted within within election (i.e. event reports are only considered as possible matches to other event reports assigned to the same general election). Because of the sequential nature of the process (where information in tables was built up gradually by user entry so the information was often needed to processed by users in a partial state) some information is duplicated across tables. The authoritate route to the key information comes from: combinedclusterentry.combinedcluster_id, verifiedcluster.clusterattempt_id and verifiedclusterentry.event_report_id.

A full description of the clustering tables is found in the diagram below:

```{r, echo=FALSE, fig.height=7, fig.width=7}


graph <- dm_create_graph(dm, focus=list(tables = c("userreallocationallocation", "userautodetectedclusterallocation", "verifiedcluster", "verifiedclusterentry", "usercombinationallocation", "combinedclusterentry")))
dm_render_graph(graph)
```

**Gary/Patrick we need a table/field level description of each of these tables here**
